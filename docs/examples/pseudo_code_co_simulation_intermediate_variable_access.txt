//////////////////////////
// Define callback

// Global variables
fmi3IntermediateStepInfo s_intermediateStepInfo;

// Callback
fmi3Status intermediateStepFinished(fmi3ComponentEnvironment componentEnvironment, fmi3IntermediateStepInfo* stepInfo, fmi3Boolean* earlyReturn)
{
  intermediateTime = stepInfo->intermediateStepTime;

  //If getting intermediate output variables allowed
  if (stepInfo->intermediateVariableGetAllowed) then {
    //Get the output variables at time = intermediateTime
    fmi3GetReal/Integer/Boolean/String(s, ...);

    //If internal integration step finished
    if (stepInfo->internalStepFinished) then {
      //Forward output variables to other FMUs or write to result files
    }
  }

  //If setting intermediate output variables allowed
  if (stepInfo->intermediateVariableSetAllowed) then {
    //Compute intermediate input variables from output varibles and 
    //variables from other FMUs. Use latest available output 
    //variables, possibly from get functions above
    inputVariables = ...
	
    //Set the input variables at time = intermediateTime
    fmi3SetReal/Integer/Boolean/String(s, ...);
  }

  //Internal execution in FMU will now continue
}

//////////////////////////
// Initialization sub-phase

// Set callback functions,
fmi3CallbackFunctions cbf;
fmi3EventInfo eventInfo;
cbf.logger = loggerFunction; // Logger function
cbf.allocateMemory = calloc;
cbf.freeMemory = free;
cbf.stepFinished = NULL;    // Synchronous execution
// Signal that early return is supported by master
cbf.intermediateStepFinished = intermediateStepFinished;   

// Create pointer to information for identifying the FMU in callbacks 
// (note: this is pseudo code, no correct pointer handling)
cbf.componentEnvironment = GUID;
// Instantiate slave
fmi3Component s = fmi3Instantiate("Tool1" , fmi3CoSimulation, GUID, "", fmi3False, fmi3False, &cbf, fmi3True, fmi3False);

if (s == NULL) then return FAILURE;

// Start and stop time 
startTime = 0;
stopTime = 10;
// Communication constant step size
h = 0.01;

// Set all variable start values (of "ScalarVariable / <type> / start")
fmi3SetReal/Integer/Boolean/String(s, ...);

// Initialize slave
fmi3SetupExperiment(s, fmi3False, 0.0, startTime, fmi3True, stopTime);
fmi3EnterInitializationMode(s);

// Set the input values at time = startTime 
fmi3SetReal/Integer/Boolean/String(s, ...);

fmi3ExitInitializationMode(s);

//////////////////////////
// Simulation sub-phase
tc = startTime; // Starting master time
step = h;       // Starting non-zero step size
while (tc < tStop) do
{
  if (step > 0) then
  { // Continuous mode (default mode)
    fmi3Bolean earlyReturn = fmi3False;
    status = fmi3DoStep(s,tc,step,...);
    switch () {
      case (status == fmi3OK):
        tc +=step;
      case (status == fmi3Warning):
        // Simplified code	
      case (status == fmi3Error or status == fmi3Fatal or status == fmi3Discard):
        // Simplified code
    };
  } 
  else
  { // Event mode
    fmi3NewDiscreteStates(s, s_eventInfo);
    if not(s_eventInfo.newDiscreteStatesNeeded) then {
      fmi3EnterContinuousMode(s);
      step = h;
    };
  };
  // Get outputs
  fmi3GetReal/Integer/Boolean/String(s, ...);
  // Set inputs
  fmi3SetReal/Integer/Boolean/String(s, ...);
};

//////////////////////////
// Shutdown sub-phase
if ((status != fmi2Error) and (status != fmi2Fatal)) then fmi3Terminate(s);

if (status != fmi2Fatal) then fmi3FreeInstance(s1);
